diff -uNr mutt-1.5.23.nntp.xterm.sidebar/color.c mutt-1.5.23.nntp.xterm.sidebar.indexcolor/color.c
--- mutt-1.5.23.nntp.xterm.sidebar/color.c	2014-12-03 02:32:53.217123600 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/color.c	2014-12-03 02:47:07.891519903 +0200
@@ -35,6 +35,8 @@
 COLOR_LINE *ColorHdrList = NULL;
 COLOR_LINE *ColorBodyList = NULL;
 COLOR_LINE *ColorIndexList = NULL;
+COLOR_LINE *ColorIndexSubjectList = NULL;
+COLOR_LINE *ColorIndexAuthorList = NULL;
 
 /* local to this file */
 static int ColorQuoteSize;
@@ -93,6 +95,14 @@
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "index_subject",	MT_COLOR_INDEX_SUBJECT },
+  { "index_author",	MT_COLOR_INDEX_AUTHOR },
+  { "index_collapsed",	MT_COLOR_INDEX_COLLAPSED },
+  { "index_date",	MT_COLOR_INDEX_DATE },
+  { "index_flags",	MT_COLOR_INDEX_FLAGS },
+  { "index_label",	MT_COLOR_INDEX_LABEL },
+  { "index_number",	MT_COLOR_INDEX_NUMBER },
+  { "index_size",	MT_COLOR_INDEX_SIZE },
   { "sidebar_new",	MT_COLOR_NEW },
   { "sidebar_flagged",	MT_COLOR_FLAGGED },
   { NULL,		0 }
@@ -366,11 +376,54 @@
   return _mutt_parse_uncolor(buf, s, data, err, 0);
 }
 
+static void
+mutt_do_uncolor (BUFFER *buf, BUFFER *s, COLOR_LINE **ColorList, 
+    			int *do_cache, int parse_uncolor)
+{
+  COLOR_LINE *tmp, *last = NULL;
+
+  do
+  {
+    mutt_extract_token (buf, s, 0);
+    if (!mutt_strcmp ("*", buf->data))
+    {
+      for (tmp = *ColorList; tmp; )
+      {
+        if (!*do_cache)
+	  *do_cache = 1;
+	last = tmp;
+	tmp = tmp->next;
+	mutt_free_color_line(&last, parse_uncolor);
+      }
+      *ColorList = NULL;
+    }
+    else
+    {
+      for (last = NULL, tmp = *ColorList; tmp; last = tmp, tmp = tmp->next)
+      {
+	if (!mutt_strcmp (buf->data, tmp->pattern))
+	{
+          if (!*do_cache)
+	    *do_cache = 1;
+	  dprint(1,(debugfile,"Freeing pattern \"%s\" from ColorList\n",
+	                       tmp->pattern));
+	  if (last)
+	    last->next = tmp->next;
+	  else
+	    *ColorList = tmp->next;
+	  mutt_free_color_line(&tmp, parse_uncolor);
+	  break;
+	}
+      }
+    }
+  }
+  while (MoreArgs (s));
+}
+
 static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
 				BUFFER *err, short parse_uncolor)
 {
   int object = 0, do_cache = 0;
-  COLOR_LINE *tmp, *last = NULL;
   COLOR_LINE **list;
 
   mutt_extract_token (buf, s, 0);
@@ -381,6 +434,13 @@
     return (-1);
   }
 
+  if (object > MT_COLOR_INDEX_AUTHOR) /* uncolor index column */
+  {
+    ColorDefs[object] = 0;
+    set_option (OPTFORCEREDRAWINDEX);
+    return (0);
+  }
+
   if (mutt_strncmp (buf->data, "index", 5) == 0)
     list = &ColorIndexList;
   else if (mutt_strncmp (buf->data, "body", 4) == 0)
@@ -424,43 +484,13 @@
     return 0;
   }
 
-  do
-  {
-    mutt_extract_token (buf, s, 0);
-    if (!mutt_strcmp ("*", buf->data))
-    {
-      for (tmp = *list; tmp; )
-      {
-        if (!do_cache)
-	  do_cache = 1;
-	last = tmp;
-	tmp = tmp->next;
-	mutt_free_color_line(&last, parse_uncolor);
-      }
-      *list = NULL;
-    }
-    else
-    {
-      for (last = NULL, tmp = *list; tmp; last = tmp, tmp = tmp->next)
-      {
-	if (!mutt_strcmp (buf->data, tmp->pattern))
-	{
-          if (!do_cache)
-	    do_cache = 1;
-	  dprint(1,(debugfile,"Freeing pattern \"%s\" from color list\n",
-	                       tmp->pattern));
-	  if (last)
-	    last->next = tmp->next;
-	  else
-	    *list = tmp->next;
-	  mutt_free_color_line(&tmp, parse_uncolor);
-	  break;
-	}
-      }
-    }
-  }
-  while (MoreArgs (s));
 
+  if (object == MT_COLOR_INDEX)
+    mutt_do_uncolor(buf, s, &ColorIndexList, &do_cache, parse_uncolor);
+  if (object == MT_COLOR_INDEX_SUBJECT)
+    mutt_do_uncolor(buf, s, &ColorIndexSubjectList, &do_cache, parse_uncolor);
+  if (object == MT_COLOR_INDEX_AUTHOR)
+    mutt_do_uncolor(buf, s, &ColorIndexAuthorList, &do_cache, parse_uncolor);
 
   if (do_cache && !option (OPTNOCURSES))
   {
@@ -700,7 +730,7 @@
 
   /* extract a regular expression if needed */
   
-  if (object == MT_COLOR_HEADER || object == MT_COLOR_BODY || object == MT_COLOR_INDEX)
+  if (object == MT_COLOR_HEADER || object == MT_COLOR_BODY || object == MT_COLOR_INDEX || object == MT_COLOR_INDEX_SUBJECT || object == MT_COLOR_INDEX_AUTHOR)
   {
     if (!MoreArgs (s))
     {
@@ -744,6 +774,18 @@
     r = add_pattern (&ColorIndexList, buf->data, 1, fg, bg, attr, err, 1);
     set_option (OPTFORCEREDRAWINDEX);
   }
+  else if (object == MT_COLOR_INDEX_SUBJECT)
+  {
+    r = add_pattern (&ColorIndexSubjectList, buf->data,
+		     1, fg, bg, attr, err, 1);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+  else if (object == MT_COLOR_INDEX_AUTHOR)
+  {
+    r = add_pattern (&ColorIndexAuthorList, buf->data,
+		     1, fg, bg, attr, err, 1);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
   else if (object == MT_COLOR_QUOTED)
   {
     if (q_level >= ColorQuoteSize)
@@ -769,7 +811,11 @@
       ColorQuote[q_level] = fgbgattr_to_color(fg, bg, attr);
   }
   else
+  {
     ColorDefs[object] = fgbgattr_to_color(fg, bg, attr);
+    if (object > MT_COLOR_INDEX_AUTHOR)
+      set_option (OPTFORCEREDRAWINDEX);
+  }
 
   return (r);
 }
diff -uNr mutt-1.5.23.nntp.xterm.sidebar/curs_lib.c mutt-1.5.23.nntp.xterm.sidebar.indexcolor/curs_lib.c
--- mutt-1.5.23.nntp.xterm.sidebar/curs_lib.c	2014-03-12 18:03:44.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/curs_lib.c	2014-12-03 02:47:07.891519903 +0200
@@ -718,6 +718,7 @@
   size_t k, k2;
   char scratch[MB_LEN_MAX];
   mbstate_t mbstate1, mbstate2;
+  int escaped = 0;
 
   memset(&mbstate1, 0, sizeof (mbstate1));
   memset(&mbstate2, 0, sizeof (mbstate2));
@@ -733,7 +734,15 @@
       k = (k == (size_t)(-1)) ? 1 : n;
       wc = replacement_char ();
     }
-    if (arboreal && wc < M_TREE_MAX)
+    if (escaped) {
+      escaped = 0;
+      w = 0;
+    }
+    else if (arboreal && wc == M_SPECIAL_INDEX) {
+      escaped = 1;
+      w = 0;
+    }
+    else if (arboreal && wc < M_TREE_MAX)
       w = 1; /* hack */
     else
     {
diff -uNr mutt-1.5.23.nntp.xterm.sidebar/doc/manual.xml.head mutt-1.5.23.nntp.xterm.sidebar.indexcolor/doc/manual.xml.head
--- mutt-1.5.23.nntp.xterm.sidebar/doc/manual.xml.head	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/doc/manual.xml.head	2014-12-03 02:47:07.892519913 +0200
@@ -2600,7 +2600,7 @@
 
 <command>color</command>
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <replaceable class="parameter">foreground</replaceable>
@@ -2615,7 +2615,7 @@
 <command>uncolor</command>
 <group choice="req">
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <option>header</option>
@@ -2658,6 +2658,14 @@
 <listitem><para>bold (highlighting bold patterns in the body of messages)</para></listitem>
 <listitem><para>error (error messages printed by Mutt)</para></listitem>
 <listitem><para>hdrdefault (default color of the message header in the pager)</para></listitem>
+<listitem><para>index_author (color of the author name in the index, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_collapsed (the number of messages in a collapsed thread in the index)</para></listitem>
+<listitem><para>index_date (color of the date field in the index)</para></listitem>
+<listitem><para>index_flags (color of the message flags in the index)</para></listitem>
+<listitem><para>index_label (color of the message label in the index)</para></listitem>
+<listitem><para>index_number (color of the message number in the index)</para></listitem>
+<listitem><para>index_size (color of the message size and line number in the index)</para></listitem>
+<listitem><para>index_subject (color of the subject in the index, uses <emphasis>pattern</emphasis>)</para></listitem>
 <listitem><para>indicator (arrow or bar used to indicate the current item in a menu)</para></listitem>
 <listitem><para>markers (the <quote>+</quote> markers at the beginning of wrapped lines in the pager)</para></listitem>
 <listitem><para>message (informational messages)</para></listitem>
diff -uNr mutt-1.5.23.nntp.xterm.sidebar/hdrline.c mutt-1.5.23.nntp.xterm.sidebar.indexcolor/hdrline.c
--- mutt-1.5.23.nntp.xterm.sidebar/hdrline.c	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/hdrline.c	2014-12-03 02:47:07.892519913 +0200
@@ -103,6 +103,34 @@
   return 0;
 }
 
+/* Takes the color to embed, the buffer to manipulate and the buffer length as
+ * arguments.
+ * Returns the number of chars written. */
+static size_t add_index_color(char *buf, size_t buflen,
+    			   format_flag flags, char color)
+{
+  int len;
+
+  /* only add color markers if we are operating on main index entries. */
+  if (!(flags & M_FORMAT_INDEX))
+    return 0;
+
+  if (color == MT_COLOR_INDEX) { /* buf might be uninitialized other cases */
+    len = mutt_strlen(buf);
+    buf += len;
+    buflen -= len;
+  }
+
+  if (buflen < 2)
+    return 0;
+
+  buf[0] = M_SPECIAL_INDEX;
+  buf[1] = color;
+  buf[2] = '\0';
+
+  return 2;
+}
+
 static void make_from (ENVELOPE *hdr, char *buf, size_t len, int do_lists)
 {
   int me;
@@ -256,6 +284,7 @@
 #define THREAD_NEW (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 1)
 #define THREAD_OLD (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 2)
   size_t len;
+  size_t colorlen;
 
   hdr = hfi->hdr;
   ctx = hfi->ctx;
@@ -307,12 +336,17 @@
       break;
     
     case 'c':
+      colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_SIZE);
       mutt_pretty_size (buf2, sizeof (buf2), (long) hdr->content->length);
-      mutt_format_s (dest, destlen, prefix, buf2);
+      mutt_format_s (dest+colorlen, destlen-colorlen, prefix, buf2);
+      add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'C':
-      snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+      colorlen = add_index_color(fmt, sizeof(fmt), flags, MT_COLOR_INDEX_NUMBER);
+      snprintf (fmt+colorlen, sizeof(fmt)-colorlen, "%%%sd", prefix);
+      add_index_color(fmt+colorlen, sizeof(fmt)-colorlen, flags, MT_COLOR_INDEX);
+
       snprintf (dest, destlen, fmt, hdr->msgno + 1);
       break;
 
@@ -411,7 +445,10 @@
 	if (do_locales)
 	  setlocale (LC_TIME, "C");
 
-	mutt_format_s (dest, destlen, prefix, buf2);
+	colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_DATE);
+	mutt_format_s (dest+colorlen, destlen-colorlen, prefix, buf2);
+	add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+
 	if (len > 0 && op != 'd' && op != 'D') /* Skip ending op */
 	  src = cp + 1;
       }
@@ -441,8 +478,10 @@
     case 'F':
       if (!optional)
       {
+	colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
         make_from (hdr->env, buf2, sizeof (buf2), 0);
-	mutt_format_s (dest, destlen, prefix, buf2);
+	mutt_format_s (dest+colorlen, destlen-colorlen, prefix, buf2);
+	add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
       }
       else if (mutt_addr_is_user (hdr->env->from))
         optional = 0;
@@ -474,7 +513,9 @@
       if (!optional)
       {
 	snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
-	snprintf (dest, destlen, fmt, (int) hdr->lines);
+	colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_SIZE);
+	snprintf (dest+colorlen, destlen-colorlen, fmt, (int) hdr->lines);
+	add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
       }
       else if (hdr->lines <= 0)
         optional = 0;
@@ -483,8 +524,10 @@
     case 'L':
       if (!optional)
       {
+	colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
 	make_from (hdr->env, buf2, sizeof (buf2), 1);
-	mutt_format_s (dest, destlen, prefix, buf2);
+	mutt_format_s (dest+colorlen, destlen-colorlen, prefix, buf2);
+	add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
       }
       else if (!check_for_mailing_list (hdr->env->to, NULL, NULL, 0) &&
 	       !check_for_mailing_list (hdr->env->cc, NULL, NULL, 0))
@@ -539,10 +582,16 @@
       snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
       if (!optional)
       {
-	if (threads && is_index && hdr->collapsed && hdr->num_hidden > 1)
-	  snprintf (dest, destlen, fmt, hdr->num_hidden);
-	else if (is_index && threads)
-	  mutt_format_s (dest, destlen, prefix, " ");
+	colorlen = add_index_color(dest, destlen, flags, 
+				   MT_COLOR_INDEX_COLLAPSED);
+	if (threads && is_index && hdr->collapsed && hdr->num_hidden > 1) {
+	  snprintf (dest+colorlen, destlen-colorlen, fmt, hdr->num_hidden);
+	  add_index_color(dest, destlen-colorlen, flags, MT_COLOR_INDEX);
+	}
+	else if (is_index && threads) {
+	  mutt_format_s (dest+colorlen, destlen-colorlen, prefix, " ");
+	  add_index_color(dest, destlen-colorlen, flags, MT_COLOR_INDEX);
+	}
 	else
 	  *dest = '\0';
       }
@@ -572,15 +621,23 @@
       {
 	if (flags & M_FORMAT_FORCESUBJ)
 	{
-	  mutt_format_s (dest, destlen, "", NONULL (hdr->env->subject));
+	  colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
+	  mutt_format_s (dest+colorlen, destlen-colorlen, "", 
+	      NONULL (hdr->env->subject));
+	  add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+
 	  snprintf (buf2, sizeof (buf2), "%s%s", hdr->tree, dest);
 	  mutt_format_s_tree (dest, destlen, prefix, buf2);
 	}
 	else
 	  mutt_format_s_tree (dest, destlen, prefix, hdr->tree);
       }
-      else
-	mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->subject));
+      else {
+	colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
+	mutt_format_s (dest+colorlen, destlen-colorlen, prefix, 
+	    NONULL (hdr->env->subject));
+	add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+      }
       break;
 
     case 'S':
@@ -683,7 +740,9 @@
 		hdr->tagged ? '*' :
 		(hdr->flagged ? '!' :
 		 (Tochars && ((i = mutt_user_is_recipient (hdr)) < mutt_strlen (Tochars)) ? Tochars[i] : ' ')));
-      mutt_format_s (dest, destlen, prefix, buf2);
+      colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_FLAGS);
+      mutt_format_s (dest+colorlen, destlen-colorlen, prefix, buf2);
+      add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'X':
@@ -703,7 +762,9 @@
        if (optional)
 	 optional = hdr->env->x_label ? 1 : 0;
 
-       mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->x_label));
+       colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_LABEL);
+       mutt_format_s (dest+colorlen, destlen-colorlen, prefix, NONULL (hdr->env->x_label));
+       add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
        break;
  
     case 'Y':
@@ -729,10 +790,12 @@
       if (optional)
 	optional = i;
 
+      colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_LABEL);
       if (i)
-        mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->x_label));
+        mutt_format_s (dest+colorlen, destlen-colorlen, prefix, NONULL (hdr->env->x_label));
       else
-        mutt_format_s (dest, destlen, prefix, "");
+        mutt_format_s (dest+colorlen, destlen-colorlen, prefix, "");
+      add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
 
       break;
 
diff -uNr mutt-1.5.23.nntp.xterm.sidebar/menu.c mutt-1.5.23.nntp.xterm.sidebar.indexcolor/menu.c
--- mutt-1.5.23.nntp.xterm.sidebar/menu.c	2014-12-03 02:32:53.219123620 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/menu.c	2014-12-03 02:50:57.326770229 +0200
@@ -30,7 +30,30 @@
 
 char* SearchBuffers[MENU_MAX];
 
-static void print_enriched_string (int attr, unsigned char *s, int do_color)
+static int get_color(int index, int type) {
+  COLOR_LINE *color;
+  HEADER *hdr = Context->hdrs[index];
+
+  switch (type) {
+    case MT_COLOR_INDEX_SUBJECT:
+      color = ColorIndexSubjectList;
+      break;
+    case MT_COLOR_INDEX_AUTHOR:
+      color = ColorIndexAuthorList;
+      break;
+    default:
+      return ColorDefs[type];
+  }
+
+  for (; color; color = color->next)
+    if (mutt_pattern_exec (color->color_pattern, M_MATCH_FULL_ADDRESS,
+	Context, hdr))
+      return color->pair;
+
+  return 0;
+}
+
+static void print_enriched_string (int index, int attr, unsigned char *s, int do_color)
 {
   wchar_t wc;
   size_t k;
@@ -162,6 +185,18 @@
       }
       if (do_color) ATTRSET(attr);
     }
+    else if(*s == M_SPECIAL_INDEX)
+    {
+      s++;
+      if (do_color) {
+	if (*s == MT_COLOR_INDEX)
+	  attrset(attr);
+	else
+	  attron(get_color(index, *s));
+      }
+      s++;
+      n -= 2;
+    }
     else if ((k = mbrtowc (&wc, (char *)s, n, &mbstate)) > 0)
     {
       addnstr ((char *)s, k);
@@ -172,9 +207,9 @@
   }
 }
 
-static void menu_make_entry (char *s, int l, MUTTMENU *menu, int i) 
+static void menu_make_entry (char *s, int l, MUTTMENU *menu, int i)
 {
-  if (menu->dialog) 
+  if (menu->dialog)
   {
     strncpy (s, menu->dialog[i], l);
     menu->current = -1; /* hide menubar */
@@ -269,7 +304,7 @@
       else if (option(OPTARROWCURSOR))
 	addstr("   ");
 
-      print_enriched_string (attr, (unsigned char *) buf, do_color);
+      print_enriched_string (i, attr, (unsigned char *) buf, do_color);
     }
     else
     {
@@ -285,12 +320,12 @@
 {
   char buf[LONG_STRING];
 
-  if (menu->dialog) 
+  if (menu->dialog)
   {
     menu->redraw &= ~REDRAW_MOTION;
     return;
   }
-  
+
   move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
   ATTRSET(menu->color (menu->oldcurrent));
 
@@ -304,7 +339,7 @@
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (buf, sizeof (buf));
       move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
-      print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
+      print_enriched_string (menu->oldcurrent, menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
     }
 
     /* now draw it in the new location */
@@ -316,14 +351,14 @@
     /* erase the current indicator */
     menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
     menu_pad_string (buf, sizeof (buf));
-    print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
+    print_enriched_string (menu->oldcurrent, menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
 
     /* now draw the new one to reflect the change */
     menu_make_entry (buf, sizeof (buf), menu, menu->current);
     menu_pad_string (buf, sizeof (buf));
     SETCOLOR(MT_COLOR_INDICATOR);
     move(menu->current - menu->top + menu->offset, SidebarWidth);
-    print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
+    print_enriched_string (menu->current, menu->color(menu->current), (unsigned char *) buf, 0);
   }
   menu->redraw &= REDRAW_STATUS;
   NORMAL_COLOR;
@@ -333,7 +368,7 @@
 {
   char buf[LONG_STRING];
   int attr = menu->color (menu->current);
-  
+
   move (menu->current + menu->offset - menu->top, SidebarWidth);
   menu_make_entry (buf, sizeof (buf), menu, menu->current);
   menu_pad_string (buf, sizeof (buf));
@@ -345,19 +380,19 @@
     ATTRSET(attr);
     addch (' ');
     menu_pad_string (buf, sizeof (buf));
-    print_enriched_string (attr, (unsigned char *) buf, 1);
+    print_enriched_string (menu->current, attr, (unsigned char *) buf, 1);
   }
   else
-    print_enriched_string (attr, (unsigned char *) buf, 0);
+    print_enriched_string (menu->current, attr, (unsigned char *) buf, 0);
   menu->redraw &= REDRAW_STATUS;
   NORMAL_COLOR;
 }
 
 static void menu_redraw_prompt (MUTTMENU *menu)
 {
-  if (menu->dialog) 
+  if (menu->dialog)
   {
-    if (option (OPTMSGERR)) 
+    if (option (OPTMSGERR))
     {
       mutt_sleep (1);
       unset_option (OPTMSGERR);
@@ -378,13 +413,13 @@
 
   if (!option (OPTMENUMOVEOFF) && menu->max <= menu->pagelen) /* less entries than lines */
   {
-    if (menu->top != 0) 
+    if (menu->top != 0)
     {
       menu->top = 0;
       set_option (OPTNEEDREDRAW);
     }
   }
-  else 
+  else
   {
     if (option (OPTMENUSCROLL) || (menu->pagelen <= 0) || (c < MenuContext))
     {
@@ -398,7 +433,7 @@
       if (menu->current < menu->top + c)
 	menu->top -= (menu->pagelen - c) * ((menu->top + menu->pagelen - 1 - menu->current) / (menu->pagelen - c)) - c;
       else if ((menu->current >= menu->top + menu->pagelen - c))
-	menu->top += (menu->pagelen - c) * ((menu->current - menu->top) / (menu->pagelen - c)) - c;	
+	menu->top += (menu->pagelen - c) * ((menu->current - menu->top) / (menu->pagelen - c)) - c;
     }
   }
 
@@ -471,7 +506,7 @@
     mutt_error _("You cannot scroll up farther.");
 }
 
-/* 
+/*
  * pageup:   jumplen == -pagelen
  * pagedown: jumplen == pagelen
  * halfup:   jumplen == -pagelen/2
@@ -781,18 +816,18 @@
 {
   switch (i)
   {
-    case OP_NEXT_ENTRY:   
+    case OP_NEXT_ENTRY:
       return OP_NEXT_LINE;
-    case OP_PREV_ENTRY:	  
+    case OP_PREV_ENTRY:
       return OP_PREV_LINE;
-    case OP_CURRENT_TOP:   case OP_FIRST_ENTRY:  
+    case OP_CURRENT_TOP:   case OP_FIRST_ENTRY:
       return OP_TOP_PAGE;
-    case OP_CURRENT_BOTTOM:    case OP_LAST_ENTRY:	  
+    case OP_CURRENT_BOTTOM:    case OP_LAST_ENTRY:
       return OP_BOTTOM_PAGE;
-    case OP_CURRENT_MIDDLE: 
-      return OP_MIDDLE_PAGE; 
+    case OP_CURRENT_MIDDLE:
+      return OP_MIDDLE_PAGE;
   }
-  
+
   return i;
 }
 
@@ -830,10 +865,10 @@
     /* allow the caller to do any local configuration */
     return (OP_REDRAW);
   }
-  
+
   if (!menu->dialog)
     menu_check_recenter (menu);
-  
+
   if (menu->redraw & REDRAW_STATUS)
     menu_redraw_status (menu);
   if (menu->redraw & REDRAW_INDEX)
@@ -842,10 +877,10 @@
     menu_redraw_motion (menu);
   else if (menu->redraw == REDRAW_CURRENT)
     menu_redraw_current (menu);
-  
+
   if (menu->dialog)
     menu_redraw_prompt (menu);
-  
+
   return OP_NULL;
 }
 
@@ -860,19 +895,19 @@
       unset_option (OPTMENUCALLER);
       return OP_NULL;
     }
-    
-    
+
+
     mutt_curs_set (0);
 
     if (menu_redraw (menu) == OP_REDRAW)
       return OP_REDRAW;
-    
+
     menu->oldcurrent = menu->current;
 
 
     /* move the cursor out of the way */
-    
-    
+
+
     if (option (OPTARROWCURSOR))
       move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
     else if (option (OPTBRAILLEFRIENDLY))
@@ -881,11 +916,11 @@
       move (menu->current - menu->top + menu->offset, COLS - 1);
 
     mutt_refresh ();
-    
+
     /* try to catch dialog keys before ops */
     if (menu->dialog && menu_dialog_dokey (menu, &i) == 0)
       return i;
-		    
+
     i = km_dokey (menu->menu);
     if (i == OP_TAG_PREFIX || i == OP_TAG_PREFIX_COND)
     {
@@ -938,7 +973,7 @@
       mutt_clear_error ();
 
     /* Convert menubar movement to scrolling */
-    if (menu->dialog) 
+    if (menu->dialog)
       i = menu_dialog_translate_op (i);
 
     switch (i)
diff -uNr mutt-1.5.23.nntp.xterm.sidebar/mutt_curses.h mutt-1.5.23.nntp.xterm.sidebar.indexcolor/mutt_curses.h
--- mutt-1.5.23.nntp.xterm.sidebar/mutt_curses.h	2014-12-03 02:32:53.219123620 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/mutt_curses.h	2014-12-03 02:47:07.893519923 +0200
@@ -123,6 +123,16 @@
   MT_COLOR_INDEX,
   MT_COLOR_NEW,
   MT_COLOR_FLAGGED,
+  /* please no non-MT_COLOR_INDEX objects after this point */
+  MT_COLOR_INDEX_SUBJECT,
+  MT_COLOR_INDEX_AUTHOR,
+  /* below only index coloring stuff that doesn't have a colorline! */
+  MT_COLOR_INDEX_COLLAPSED,
+  MT_COLOR_INDEX_DATE,
+  MT_COLOR_INDEX_FLAGS,
+  MT_COLOR_INDEX_LABEL,
+  MT_COLOR_INDEX_NUMBER,
+  MT_COLOR_INDEX_SIZE,
   MT_COLOR_MAX
 };
 
@@ -176,6 +186,8 @@
 extern COLOR_LINE *ColorHdrList;
 extern COLOR_LINE *ColorBodyList;
 extern COLOR_LINE *ColorIndexList;
+extern COLOR_LINE *ColorIndexSubjectList;
+extern COLOR_LINE *ColorIndexAuthorList;
 
 void ci_init_color (void);
 void ci_start_color (void);
diff -uNr mutt-1.5.23.nntp.xterm.sidebar/mutt.h mutt-1.5.23.nntp.xterm.sidebar.indexcolor/mutt.h
--- mutt-1.5.23.nntp.xterm.sidebar/mutt.h	2014-12-03 02:32:53.219123620 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar.indexcolor/mutt.h	2014-12-03 02:47:07.893519923 +0200
@@ -161,6 +161,8 @@
 #define M_TREE_MISSING		13
 #define M_TREE_MAX		14
 
+#define M_SPECIAL_INDEX		M_TREE_MAX
+
 #define M_THREAD_COLLAPSE	(1<<0)
 #define M_THREAD_UNCOLLAPSE	(1<<1)
 #define M_THREAD_GET_HIDDEN	(1<<2)
