diff -uNr mutt-1.5.23.nntp.xterm/buffy.c mutt-1.5.23.nntp.xterm.sidebar/buffy.c
--- mutt-1.5.23.nntp.xterm/buffy.c	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/buffy.c	2014-12-03 02:32:53.217123600 +0200
@@ -161,6 +161,49 @@
   }
 }
 
+static int buffy_compare_name(const void *a, const void *b) {
+  const BUFFY *b1 = * (BUFFY * const *) a;
+  const BUFFY *b2 = * (BUFFY * const *) b;
+
+  return mutt_strcoll(b1->path, b2->path);
+}
+
+static BUFFY *buffy_sort(BUFFY *b)
+{
+  BUFFY *tmp = b;
+  int buffycount = 0;
+  BUFFY **ary;
+  int i;
+
+  if (!option(OPTSIDEBARSORT))
+    return b;
+
+  for (; tmp != NULL; tmp = tmp->next)
+    buffycount++;
+
+  ary = (BUFFY **) safe_calloc(buffycount, sizeof (*ary));
+
+  tmp = b;
+  for (i = 0; tmp != NULL; tmp = tmp->next, i++) {
+    ary[i] = tmp;
+  }
+
+  qsort(ary, buffycount, sizeof(*ary), buffy_compare_name);
+
+  for (i = 0; i < buffycount - 1; i++) {
+    ary[i]->next = ary[i+1];
+  }
+  ary[buffycount - 1]->next = NULL;
+  for (i = 1; i < buffycount; i++) {
+    ary[i]->prev = ary[i-1];
+  }
+  ary[0]->prev = NULL;
+
+  tmp = ary[0];
+  free(ary);
+  return tmp;
+}
+
 BUFFY *mutt_find_mailbox (const char *path)
 {
   BUFFY *tmp = NULL;
@@ -282,6 +325,7 @@
     else
       (*tmp)->size = 0;
   }
+  Incoming = buffy_sort(Incoming);
   return 0;
 }
 
@@ -340,6 +384,68 @@
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_maildir_update (BUFFY* mailbox)
+{
+  char path[_POSIX_PATH_MAX];
+  DIR *dirp;
+  struct dirent *de;
+  char *p;
+
+  mailbox->msgcount = 0;
+  mailbox->msg_unread = 0;
+  mailbox->msg_flagged = 0;
+
+  snprintf (path, sizeof (path), "%s/new", mailbox->path);
+        
+  if ((dirp = opendir (path)) == NULL)
+  {   
+    mailbox->magic = 0;
+    return;
+  } 
+      
+  while ((de = readdir (dirp)) != NULL)
+  {
+    if (*de->d_name == '.')
+      continue;
+
+    if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+      mailbox->new = 1;
+      mailbox->msgcount++;
+      mailbox->msg_unread++;
+    }
+  }
+
+  closedir (dirp);
+  snprintf (path, sizeof (path), "%s/cur", mailbox->path);
+        
+  if ((dirp = opendir (path)) == NULL)
+  {   
+    mailbox->magic = 0;
+    return;
+  } 
+      
+  while ((de = readdir (dirp)) != NULL)
+  {
+    if (*de->d_name == '.')
+      continue;
+
+    if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+      mailbox->msgcount++;
+      if ((p = strstr (de->d_name, ":2,"))) {
+        if (!strchr (p + 3, 'T')) {
+          if (!strchr (p + 3, 'S'))
+            mailbox->msg_unread++;
+          if (strchr(p + 3, 'F'))
+            mailbox->msg_flagged++;
+        }
+      }
+    }
+  }
+
+  closedir (dirp);
+}
+
 /* returns 1 if mailbox has new mail */ 
 static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
 {
@@ -371,6 +477,20 @@
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_mbox_update (BUFFY* mailbox)
+{
+  CONTEXT *ctx = NULL;
+
+  ctx = mx_open_mailbox(mailbox->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
+  if(ctx)
+  {
+    mailbox->msgcount = ctx->msgcount;
+    mailbox->msg_unread = ctx->unread;
+    mx_close_mailbox(ctx, 0);
+  }
+}
+
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
@@ -456,16 +576,19 @@
       {
       case M_MBOX:
       case M_MMDF:
+	buffy_mbox_update (tmp);
 	if (buffy_mbox_hasnew (tmp, &sb) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MAILDIR:
+	buffy_maildir_update (tmp);
 	if (buffy_maildir_hasnew (tmp) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MH:
+	mh_buffy_update (tmp->path, &tmp->msgcount, &tmp->msg_unread, &tmp->msg_flagged);
 	mh_buffy(tmp);
 	if (tmp->new)
 	  BuffyCount++;
diff -uNr mutt-1.5.23.nntp.xterm/buffy.h mutt-1.5.23.nntp.xterm.sidebar/buffy.h
--- mutt-1.5.23.nntp.xterm/buffy.h	2014-03-12 18:03:44.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/buffy.h	2014-12-03 02:32:53.217123600 +0200
@@ -25,7 +25,11 @@
   char path[_POSIX_PATH_MAX];
   off_t size;
   struct buffy_t *next;
+  struct buffy_t *prev;
   short new;			/* mailbox has new mail */
+  int msgcount;			/* total number of messages */
+  int msg_unread;		/* number of unread messages */
+  int msg_flagged;		/* number of flagged messages */
   short notified;		/* user has been notified */
   short magic;			/* mailbox type */
   short newly_created;		/* mbox or mmdf just popped into existence */
diff -uNr mutt-1.5.23.nntp.xterm/color.c mutt-1.5.23.nntp.xterm.sidebar/color.c
--- mutt-1.5.23.nntp.xterm/color.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/color.c	2014-12-03 02:32:53.217123600 +0200
@@ -93,6 +93,8 @@
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "sidebar_new",	MT_COLOR_NEW },
+  { "sidebar_flagged",	MT_COLOR_FLAGGED },
   { NULL,		0 }
 };
 
diff -uNr mutt-1.5.23.nntp.xterm/compose.c mutt-1.5.23.nntp.xterm.sidebar/compose.c
--- mutt-1.5.23.nntp.xterm/compose.c	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/compose.c	2014-12-03 02:38:03.539176666 +0200
@@ -1,21 +1,21 @@
 /*
  * Copyright (C) 1996-2000,2002,2007 Michael R. Elkins <me@mutt.org>
  * Copyright (C) 2004 g10 Code GmbH
- * 
+ *
  *     This program is free software; you can redistribute it and/or modify
  *     it under the terms of the GNU General Public License as published by
  *     the Free Software Foundation; either version 2 of the License, or
  *     (at your option) any later version.
- * 
+ *
  *     This program is distributed in the hope that it will be useful,
  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *     GNU General Public License for more details.
- * 
+ *
  *     You should have received a copy of the GNU General Public License
  *     along with this program; if not, write to the Free Software
  *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */ 
+ */
 
 #if HAVE_CONFIG_H
 # include "config.h"
@@ -83,7 +83,7 @@
 
 #define HDR_XOFFSET 14
 #define TITLE_FMT "%14s" /* Used for Prompts, which are ASCII */
-#define W (COLS - HDR_XOFFSET)
+#define W (COLS - HDR_XOFFSET - SidebarWidth)
 
 static const char * const Prompts[] =
 {
@@ -144,7 +144,7 @@
 
 static void redraw_crypt_lines (HEADER *msg)
 {
-  mvprintw (HDR_CRYPT, 0, TITLE_FMT, "Security: ");
+  mvprintw (HDR_CRYPT, SidebarWidth, TITLE_FMT, "Security: ");
 
   if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
   {
@@ -176,7 +176,7 @@
   }
 
   clrtoeol ();
-  move (HDR_CRYPTINFO, 0);
+  move (HDR_CRYPTINFO, SidebarWidth);
   clrtoeol ();
 
   if ((WithCrypto & APPLICATION_PGP)
@@ -194,7 +194,7 @@
       && (msg->security & ENCRYPT)
       && SmimeCryptAlg
       && *SmimeCryptAlg) {
-      mvprintw (HDR_CRYPTINFO, 40, "%s%s", _("Encrypt with: "),
+      mvprintw (HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
 		NONULL(SmimeCryptAlg));
   }
 }
@@ -207,7 +207,7 @@
   int c;
   char *t;
 
-  mvprintw (HDR_MIX, 0, TITLE_FMT, "Mix: ");
+  mvprintw (HDR_MIX, SidebarWidth, TITLE_FMT, "Mix: ");
 
   if (!chain)
   {
@@ -215,14 +215,14 @@
     clrtoeol ();
     return;
   }
-  
+
   for (c = 12; chain; chain = chain->next)
   {
     t = chain->data;
     if (t && t[0] == '0' && t[1] == '\0')
       t = "<random>";
-    
-    if (c + mutt_strlen (t) + 2 >= COLS)
+
+    if (c + mutt_strlen (t) + 2 >= COLS - SidebarWidth)
       break;
 
     addstr (NONULL(t));
@@ -251,13 +251,13 @@
 		 pretty, i+1);
       return -1;
     }
-    
+
     if(idx[i]->content->stamp < st.st_mtime)
     {
       mutt_pretty_mailbox(pretty, sizeof (pretty));
       snprintf(msg, sizeof(msg), _("%s [#%d] modified. Update encoding?"),
 	       pretty, i+1);
-      
+
       if((r = mutt_yesorno(msg, M_YES)) == M_YES)
 	mutt_update_encoding(idx[i]->content);
       else if(r == -1)
@@ -274,7 +274,7 @@
 
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), addr, 1);
-  mvprintw (line, 0, TITLE_FMT, Prompts[line - 1]);
+  mvprintw (line, SidebarWidth, TITLE_FMT, Prompts[line - 1]);
   mutt_paddstr (W, buf);
 }
 
@@ -292,9 +292,9 @@
   }
   else
   {
-    mvprintw (HDR_TO, 0, TITLE_FMT , Prompts[HDR_NEWSGROUPS - 1]);
+    mvprintw (HDR_TO, SidebarWidth, TITLE_FMT , Prompts[HDR_NEWSGROUPS - 1]);
     mutt_paddstr (W, NONULL (msg->env->newsgroups));
-    mvprintw (HDR_CC, 0, TITLE_FMT , Prompts[HDR_FOLLOWUPTO - 1]);
+    mvprintw (HDR_CC, SidebarWidth, TITLE_FMT , Prompts[HDR_FOLLOWUPTO - 1]);
     mutt_paddstr (W, NONULL (msg->env->followup_to));
     if (option (OPTXCOMMENTTO))
     {
@@ -317,7 +317,7 @@
 #endif
 
   SETCOLOR (MT_COLOR_STATUS);
-  mvaddstr (HDR_ATTACH - 1, 0, _("-- Attachments"));
+  mvaddstr (HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
   clrtoeol ();
 
   NORMAL_COLOR;
@@ -327,7 +327,7 @@
 {
   char buf[HUGE_STRING] = ""; /* needs to be large for alias expansion */
   char *err = NULL;
-  
+
   mutt_addrlist_to_local (*addr);
   rfc822_write_address (buf, sizeof (buf), *addr, 0);
   if (mutt_get_field (Prompts[line - 1], buf, sizeof (buf), M_ALIAS) == 0)
@@ -353,9 +353,9 @@
   /* redraw the expanded list so the user can see the result */
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), *addr, 1);
-  move (line, HDR_XOFFSET);
+  move (line, HDR_XOFFSET+SidebarWidth);
   mutt_paddstr (W, buf);
-  
+
   return 0;
 }
 
@@ -390,7 +390,7 @@
   for (; x < *idxlen - 1; x++)
     idx[x] = idx[x+1];
   menu->max = --(*idxlen);
-  
+
   return (0);
 }
 
@@ -407,13 +407,13 @@
 }
 
 
-/* 
+/*
  * cum_attachs_size: Cumulative Attachments Size
  *
  * Returns the total number of bytes used by the attachments in the
  * attachment list _after_ content-transfer-encodings have been
  * applied.
- * 
+ *
  */
 
 static unsigned long cum_attachs_size (MUTTMENU *menu)
@@ -423,7 +423,7 @@
   ATTACHPTR **idx = menu->data;
   CONTENT *info;
   BODY *b;
-  
+
   for (i = 0, s = 0; i < menu->max; i++)
   {
     b = idx[i]->content;
@@ -452,16 +452,16 @@
 }
 
 /* prototype for use below */
-static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, 
+static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu,
       const char *p);
 
 /*
  * compose_format_str()
  *
- * %a = total number of attachments 
+ * %a = total number of attachments
  * %h = hostname  [option]
- * %l = approx. length of current message (in bytes) 
- * %v = Mutt version 
+ * %l = approx. length of current message (in bytes)
+ * %v = Mutt version
  *
  * This function is similar to status_format_str().  Look at that function for
  * help when modifying this function.
@@ -518,10 +518,10 @@
   return (src);
 }
 
-static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, 
+static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu,
       const char *p)
 {
-  mutt_FormatString (buf, buflen, col, p, compose_format_str, 
+  mutt_FormatString (buf, buflen, col, p, compose_format_str,
         (unsigned long) menu, 0);
 }
 
@@ -575,7 +575,7 @@
   else
 #endif
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeHelp);
-  
+
   while (loop)
   {
 #ifdef USE_NNTP
@@ -614,7 +614,7 @@
 	  break;
 #endif
 	menu->redraw = edit_address_list (HDR_CC, &msg->env->cc);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);	
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
 #ifdef USE_NNTP
       case OP_COMPOSE_EDIT_NEWSGROUPS:
@@ -685,7 +685,7 @@
 	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
 	{
 	  mutt_str_replace (&msg->env->subject, buf);
-	  move (HDR_SUBJECT, HDR_XOFFSET);
+	  move (HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
 	  if (msg->env->subject)
 	    mutt_paddstr (W, msg->env->subject);
 	  else
@@ -703,7 +703,7 @@
 	{
 	  strfcpy (fcc, buf, fcclen);
 	  mutt_pretty_mailbox (fcc, fcclen);
-	  move (HDR_FCC, HDR_XOFFSET);
+	  move (HDR_FCC, HDR_XOFFSET + SidebarWidth);
 	  mutt_paddstr (W, fcc);
 	  fccSet = 1;
 	}
@@ -764,13 +764,13 @@
 
       case OP_COMPOSE_ATTACH_KEY:
         if (!(WithCrypto & APPLICATION_PGP))
-          break;       
+          break;
 	if (idxlen == idxmax)
         {
 	  safe_realloc (&idx, sizeof (ATTACHPTR *) * (idxmax += 5));
 	  menu->data = idx;
 	}
-	
+
 	idx[idxlen] = (ATTACHPTR *) safe_calloc (1, sizeof (ATTACHPTR));
 	if ((idx[idxlen]->content = crypt_pgp_make_key_attachment(NULL)) != NULL)
 	{
@@ -787,7 +787,7 @@
 	  menu->redraw = REDRAW_FULL;
 	  unset_option(OPTNEEDREDRAW);
 	}
-	
+
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
 
@@ -830,7 +830,7 @@
 	      FREE (&idx[idxlen]);
 	    }
 	  }
-	  
+
 	  FREE (&files);
 	  if (!error) mutt_clear_error ();
 
@@ -915,7 +915,7 @@
 
 	  this = Context; /* remember current folder and sort methods*/
 	  oldSort = Sort; oldSortAux = SortAux;
-	  
+
 	  Context = ctx;
 	  set_option(OPTATTACHMSG);
 	  mutt_message _("Tag the messages you want to attach!");
@@ -957,7 +957,7 @@
 	  }
 	  menu->redraw |= REDRAW_FULL;
 
-	  if (close == OP_QUIT) 
+	  if (close == OP_QUIT)
 	    mx_close_mailbox (Context, NULL);
 	  else
 	    mx_fastclose_mailbox (Context);
@@ -995,9 +995,9 @@
         break;
 
 #define CURRENT idx[menu->current]->content
-      
+
       case OP_COMPOSE_TOGGLE_RECODE:
-      {      
+      {
         CHECK_COUNT;
         if (!mutt_is_text_part (CURRENT))
         {
@@ -1049,7 +1049,7 @@
 	}
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
-      
+
       case OP_COMPOSE_TOGGLE_DISPOSITION:
 	/* toggle the content-disposition between inline/attachment */
 	idx[menu->current]->content->disposition = (idx[menu->current]->content->disposition == DISPINLINE) ? DISPATTACH : DISPINLINE;
@@ -1093,19 +1093,19 @@
         /* Note: We don't invoke send2-hook here, since we want to leave
 	 * users an opportunity to change settings from the ":" prompt.
 	 */
-      
+
         if(check_attachments(idx, idxlen) != 0)
         {
 	  menu->redraw = REDRAW_FULL;
 	  break;
 	}
 
-      
+
 #ifdef MIXMASTER
         if (msg->chain && mix_check_message (msg) != 0)
 	  break;
 #endif
-      
+
 	if (!fccSet && *fcc)
 	{
 	  if ((i = query_quadoption (OPT_COPY,
@@ -1160,7 +1160,7 @@
 
         /* No send2hook since this doesn't change the message. */
         break;
-      
+
       case OP_COMPOSE_RENAME_FILE:
 	CHECK_COUNT;
 	strfcpy (fname, idx[menu->current]->content->filename, sizeof (fname));
@@ -1177,13 +1177,13 @@
 	  mutt_expand_path (fname, sizeof (fname));
 	  if(mutt_rename_file (idx[menu->current]->content->filename, fname))
 	    break;
-	  
+
 	  mutt_str_replace (&idx[menu->current]->content->filename, fname);
 	  menu->redraw = REDRAW_CURRENT;
 
 	  if(idx[menu->current]->content->stamp >= st.st_mtime)
 	    mutt_stamp_attachment(idx[menu->current]->content);
-	  
+
 	}
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
@@ -1204,7 +1204,7 @@
 
 	  /* Call to lookup_mime_type () ?  maybe later */
 	  type[0] = 0;
-	  if (mutt_get_field ("Content-Type: ", type, sizeof (type), 0) != 0 
+	  if (mutt_get_field ("Content-Type: ", type, sizeof (type), 0) != 0
 	      || !type[0])
 	    continue;
 
@@ -1253,7 +1253,7 @@
 	    menu->redraw = REDRAW_FULL;
 	  }
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);    
+        mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
 
       case OP_COMPOSE_EDIT_MIME:
@@ -1330,7 +1330,7 @@
 	  menu->redraw = REDRAW_FULL;
 	  break;
 	}
-      
+
 	loop = 0;
 	r = 1;
 	break;
@@ -1423,7 +1423,7 @@
 
 #ifdef MIXMASTER
       case OP_COMPOSE_MIX:
-      
+
       	mix_make_chain (&msg->chain, &menu->redraw);
         mutt_message_hook (NULL, msg, M_SEND2HOOK);
         break;
@@ -1432,7 +1432,7 @@
     }
 
     /* Draw formatted compose status line */
-    if (menu->redraw & REDRAW_STATUS) 
+    if (menu->redraw & REDRAW_STATUS)
     {
 	compose_status_line (buf, sizeof (buf), 0, menu, NONULL(ComposeFormat));
 	move(option (OPTSTATUSONTOP) ? 0 : LINES-2, 0);
@@ -1461,4 +1461,3 @@
 
   return (r);
 }
-
diff -uNr mutt-1.5.23.nntp.xterm/curs_main.c mutt-1.5.23.nntp.xterm.sidebar/curs_main.c
--- mutt-1.5.23.nntp.xterm/curs_main.c	2014-12-03 02:10:11.933685529 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/curs_main.c	2014-12-03 02:32:53.218123610 +0200
@@ -27,7 +27,9 @@
 #include "mailbox.h"
 #include "mapping.h"
 #include "sort.h"
+#include "buffy.h"
 #include "mx.h"
+#include "sidebar.h"
 
 #ifdef USE_POP
 #include "pop.h"
@@ -556,8 +558,12 @@
        menu->redraw |= REDRAW_STATUS;
      if (do_buffy_notify)
      {
-       if (mutt_buffy_notify () && option (OPTBEEPNEW))
- 	beep ();
+       if (mutt_buffy_notify ())
+       {
+         menu->redraw |= REDRAW_FULL;
+         if (option (OPTBEEPNEW))
+           beep ();
+       }
      }
      else
        do_buffy_notify = 1;
@@ -569,6 +575,7 @@
     if (menu->redraw & REDRAW_FULL)
     {
       menu_redraw_full (menu);
+      draw_sidebar(menu->menu);
       mutt_show_error ();
     }
 
@@ -591,9 +598,12 @@
 
       if (menu->redraw & REDRAW_STATUS)
       {
+	DrawFullLine = 1;
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+	DrawFullLine = 0;
 	move (option (OPTSTATUSONTOP) ? 0 : LINES-2, 0);
 	SETCOLOR (MT_COLOR_STATUS);
+	set_buffystats(Context);
 	mutt_paddstr (COLS, buf);
 	NORMAL_COLOR;
 	menu->redraw &= ~REDRAW_STATUS;
@@ -613,7 +623,7 @@
 	menu->oldcurrent = -1;
 
       if (option (OPTARROWCURSOR))
-	move (menu->current - menu->top + menu->offset, 2);
+	move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
       else if (option (OPTBRAILLEFRIENDLY))
 	move (menu->current - menu->top + menu->offset, 0);
       else
@@ -1294,6 +1304,7 @@
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_SIDEBAR_OPEN:
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
       case OP_MAIN_CHANGE_FOLDER_READONLY:
@@ -1348,7 +1359,11 @@
 #endif
 	  mutt_buffy (buf, sizeof (buf));
 
-	  if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
+          if ( op == OP_SIDEBAR_OPEN ) {
+              if(!CurBuffy)
+                break;
+            strncpy( buf, CurBuffy->path, sizeof(buf) );  
+	    } else if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
 	  {
 	    if (menu->menu == MENU_PAGER)
 	    {
@@ -1374,6 +1389,7 @@
 	else
 #endif
 	mutt_expand_path (buf, sizeof (buf));
+        set_curbuffy(buf);
 	if (mx_get_magic (buf) <= 0)
 	{
 	  mutt_error (_("%s is not a mailbox."), buf);
@@ -2515,6 +2531,12 @@
 	mutt_what_key();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+        scroll_sidebar(op, menu->menu);
+        break;
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
diff -uNr mutt-1.5.23.nntp.xterm/flags.c mutt-1.5.23.nntp.xterm.sidebar/flags.c
--- mutt-1.5.23.nntp.xterm/flags.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/flags.c	2014-12-03 02:32:53.218123610 +0200
@@ -22,8 +22,10 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mutt_menu.h"
 #include "sort.h"
 #include "mx.h"
+#include "sidebar.h"
 
 void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
 {
@@ -263,6 +265,7 @@
    */
   if (h->searched && (changed != h->changed || deleted != ctx->deleted || tagged != ctx->tagged || flagged != ctx->flagged))
     h->searched = 0;
+	draw_sidebar(0);
 }
 
 void mutt_tag_set_flag (int flag, int bf)
diff -uNr mutt-1.5.23.nntp.xterm/functions.h mutt-1.5.23.nntp.xterm.sidebar/functions.h
--- mutt-1.5.23.nntp.xterm/functions.h	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/functions.h	2014-12-03 02:32:53.218123610 +0200
@@ -188,6 +188,11 @@
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
 
 
+ { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+ { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+ { "sidebar-next",		OP_SIDEBAR_NEXT, NULL },
+ { "sidebar-prev",		OP_SIDEBAR_PREV, NULL },
+ { "sidebar-open",		OP_SIDEBAR_OPEN, NULL },
   { NULL,			0,				NULL }
 };
 
@@ -302,6 +307,11 @@
 
   { "what-key",		OP_WHAT_KEY,		NULL },
 
+  { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+  { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+  { "sidebar-next",	OP_SIDEBAR_NEXT, NULL },
+  { "sidebar-prev",	OP_SIDEBAR_PREV, NULL },
+  { "sidebar-open", OP_SIDEBAR_OPEN, NULL },
   { NULL,		0,				NULL }
 };
 
diff -uNr mutt-1.5.23.nntp.xterm/globals.h mutt-1.5.23.nntp.xterm.sidebar/globals.h
--- mutt-1.5.23.nntp.xterm/globals.h	2014-12-03 02:10:11.933685529 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/globals.h	2014-12-03 02:32:53.218123610 +0200
@@ -128,6 +128,7 @@
 WHERE char *SendCharset;
 WHERE char *Sendmail;
 WHERE char *Shell;
+WHERE char *SidebarDelim;
 WHERE char *Signature;
 WHERE char *SimpleSearch;
 #if USE_SMTP
@@ -226,6 +227,9 @@
 WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
+WHERE struct buffy_t *CurBuffy INITVAL(0);
+WHERE short DrawFullLine INITVAL(0);
+WHERE short SidebarWidth;
 #ifdef USE_IMAP
 WHERE short ImapKeepalive;
 WHERE short ImapPipelineDepth;
diff -uNr mutt-1.5.23.nntp.xterm/imap/command.c mutt-1.5.23.nntp.xterm.sidebar/imap/command.c
--- mutt-1.5.23.nntp.xterm/imap/command.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/imap/command.c	2014-12-03 02:32:53.218123610 +0200
@@ -1012,6 +1012,13 @@
 	     opened */
 	  status->uidnext = oldun;
 
+        /* Added to make the sidebar show the correct numbers */
+        if (status->messages)
+        {
+          inc->msgcount = status->messages;
+          inc->msg_unread = status->unseen;
+        }
+
         FREE (&value);
         return;
       }
diff -uNr mutt-1.5.23.nntp.xterm/imap/imap.c mutt-1.5.23.nntp.xterm.sidebar/imap/imap.c
--- mutt-1.5.23.nntp.xterm/imap/imap.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/imap/imap.c	2014-12-03 02:32:53.218123610 +0200
@@ -1514,7 +1514,7 @@
 
     imap_munge_mbox_name (munged, sizeof (munged), name);
     snprintf (command, sizeof (command),
-	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)", munged);
+	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)", munged);
 
     if (imap_exec (idata, command, IMAP_CMD_QUEUE) < 0)
     {
diff -uNr mutt-1.5.23.nntp.xterm/init.h mutt-1.5.23.nntp.xterm.sidebar/init.h
--- mutt-1.5.23.nntp.xterm/init.h	2014-12-03 02:12:06.273819281 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/init.h	2014-12-03 02:32:53.218123610 +0200
@@ -2143,6 +2143,27 @@
   ** not used.
   ** (PGP only)
   */
+  {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, "|"},
+  /*
+  ** .pp
+  ** This specifies the delimiter between the sidebar (if visible) and 
+  ** other screens.
+  */
+  { "sidebar_visible", DT_BOOL, R_BOTH, OPTSIDEBAR, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to show sidebar (left-side list of folders).
+  */
+  { "sidebar_sort", DT_BOOL, R_BOTH, OPTSIDEBARSORT, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to sort the sidebar alphabetically.
+  */
+  { "sidebar_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+  /*
+  ** .pp
+  ** The width of the sidebar.
+  */
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff -uNr mutt-1.5.23.nntp.xterm/mailbox.h mutt-1.5.23.nntp.xterm.sidebar/mailbox.h
--- mutt-1.5.23.nntp.xterm/mailbox.h	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mailbox.h	2014-12-03 02:32:53.219123620 +0200
@@ -27,6 +27,7 @@
 #define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
 				* safe_fopen() for mbox-style folders.
 				*/
+#define M_PEEK		(1<<5) /* revert atime back after taking a look (if applicable) */
 
 /* mx_open_new_message() */
 #define M_ADD_FROM	1	/* add a From_ line */
diff -uNr mutt-1.5.23.nntp.xterm/Makefile.am mutt-1.5.23.nntp.xterm.sidebar/Makefile.am
--- mutt-1.5.23.nntp.xterm/Makefile.am	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/Makefile.am	2014-12-03 02:32:53.216123590 +0200
@@ -32,6 +32,7 @@
 	rfc822.c rfc1524.c rfc2047.c rfc2231.c rfc3676.c \
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
+	sidebar.c \
 	muttlib.c editmsg.c mbyte.c \
 	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
 
diff -uNr mutt-1.5.23.nntp.xterm/mbox.c mutt-1.5.23.nntp.xterm.sidebar/mbox.c
--- mutt-1.5.23.nntp.xterm/mbox.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mbox.c	2014-12-03 02:32:53.219123620 +0200
@@ -100,6 +100,7 @@
     mutt_perror (ctx->path);
     return (-1);
   }
+  ctx->atime = sb.st_atime;
   ctx->mtime = sb.st_mtime;
   ctx->size = sb.st_size;
 
@@ -251,6 +252,7 @@
 
   ctx->size = sb.st_size;
   ctx->mtime = sb.st_mtime;
+  ctx->atime = sb.st_atime;
 
 #ifdef NFS_ATTRIBUTE_HACK
   if (sb.st_mtime > sb.st_atime)
diff -uNr mutt-1.5.23.nntp.xterm/menu.c mutt-1.5.23.nntp.xterm.sidebar/menu.c
--- mutt-1.5.23.nntp.xterm/menu.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/menu.c	2014-12-03 02:32:53.219123620 +0200
@@ -24,6 +24,7 @@
 #include "mutt_curses.h"
 #include "mutt_menu.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 extern size_t UngetCount;
 
@@ -186,7 +187,7 @@
 {
   char *scratch = safe_strdup (s);
   int shift = option (OPTARROWCURSOR) ? 3 : 0;
-  int cols = COLS - shift;
+  int cols = COLS - shift - SidebarWidth;
 
   mutt_format_string (s, n, cols, cols, FMT_LEFT, ' ', scratch, mutt_strlen (scratch), 1);
   s[n - 1] = 0;
@@ -239,6 +240,7 @@
   int do_color;
   int attr;
 
+  draw_sidebar(1);
   for (i = menu->top; i < menu->top + menu->pagelen; i++)
   {
     if (i < menu->max)
@@ -249,7 +251,7 @@
       menu_pad_string (buf, sizeof (buf));
 
       ATTRSET(attr);
-      move(i - menu->top + menu->offset, 0);
+      move(i - menu->top + menu->offset, SidebarWidth);
       do_color = 1;
 
       if (i == menu->current)
@@ -272,7 +274,7 @@
     else
     {
       NORMAL_COLOR;
-      CLEARLINE(i - menu->top + menu->offset);
+      CLEARLINE_WIN(i - menu->top + menu->offset);
     }
   }
   NORMAL_COLOR;
@@ -289,7 +291,7 @@
     return;
   }
   
-  move (menu->oldcurrent + menu->offset - menu->top, 0);
+  move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
   ATTRSET(menu->color (menu->oldcurrent));
 
   if (option (OPTARROWCURSOR))
@@ -301,13 +303,13 @@
     {
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (buf, sizeof (buf));
-      move (menu->oldcurrent + menu->offset - menu->top, 3);
+      move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
       print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
     }
 
     /* now draw it in the new location */
     SETCOLOR(MT_COLOR_INDICATOR);
-    mvaddstr(menu->current + menu->offset - menu->top, 0, "->");
+    mvaddstr(menu->current + menu->offset - menu->top, SidebarWidth, "->");
   }
   else
   {
@@ -320,7 +322,7 @@
     menu_make_entry (buf, sizeof (buf), menu, menu->current);
     menu_pad_string (buf, sizeof (buf));
     SETCOLOR(MT_COLOR_INDICATOR);
-    move(menu->current - menu->top + menu->offset, 0);
+    move(menu->current - menu->top + menu->offset, SidebarWidth);
     print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
   }
   menu->redraw &= REDRAW_STATUS;
@@ -332,7 +334,7 @@
   char buf[LONG_STRING];
   int attr = menu->color (menu->current);
   
-  move (menu->current + menu->offset - menu->top, 0);
+  move (menu->current + menu->offset - menu->top, SidebarWidth);
   menu_make_entry (buf, sizeof (buf), menu, menu->current);
   menu_pad_string (buf, sizeof (buf));
 
@@ -872,7 +874,7 @@
     
     
     if (option (OPTARROWCURSOR))
-      move (menu->current - menu->top + menu->offset, 2);
+      move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
     else if (option (OPTBRAILLEFRIENDLY))
       move (menu->current - menu->top + menu->offset, 0);
     else
diff -uNr mutt-1.5.23.nntp.xterm/mh.c mutt-1.5.23.nntp.xterm.sidebar/mh.c
--- mutt-1.5.23.nntp.xterm/mh.c	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mh.c	2014-12-03 02:32:53.219123620 +0200
@@ -295,6 +295,28 @@
   mhs_free_sequences (&mhs);
 }
 
+void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg_flagged)
+{
+  int i;
+  struct mh_sequences mhs;
+  memset (&mhs, 0, sizeof (mhs));
+
+  if (mh_read_sequences (&mhs, path) < 0)
+    return;
+
+  msgcount = 0;
+  msg_unread = 0;
+  msg_flagged = 0;
+  for (i = 0; i <= mhs.max; i++)
+    msgcount++;
+  if (mhs_check (&mhs, i) & MH_SEQ_UNSEEN) {
+    msg_unread++;
+  }
+  if (mhs_check (&mhs, i) & MH_SEQ_FLAGGED)
+    msg_flagged++;
+  mhs_free_sequences (&mhs);
+}
+
 static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
 {
   int fd;
diff -uNr mutt-1.5.23.nntp.xterm/mutt_curses.h mutt-1.5.23.nntp.xterm.sidebar/mutt_curses.h
--- mutt-1.5.23.nntp.xterm/mutt_curses.h	2014-03-12 18:03:45.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mutt_curses.h	2014-12-03 02:32:53.219123620 +0200
@@ -64,6 +64,7 @@
 #undef lines
 #endif /* lines */
 
+#define CLEARLINE_WIN(x) move(x,SidebarWidth), clrtoeol()
 #define CLEARLINE(x) move(x,0), clrtoeol()
 #define CENTERLINE(x,y) move(y, (COLS-strlen(x))/2), addstr(x)
 #define BEEP() do { if (option (OPTBEEP)) beep(); } while (0)
@@ -120,6 +121,8 @@
   MT_COLOR_BOLD,
   MT_COLOR_UNDERLINE,
   MT_COLOR_INDEX,
+  MT_COLOR_NEW,
+  MT_COLOR_FLAGGED,
   MT_COLOR_MAX
 };
 
diff -uNr mutt-1.5.23.nntp.xterm/mutt.h mutt-1.5.23.nntp.xterm.sidebar/mutt.h
--- mutt-1.5.23.nntp.xterm/mutt.h	2014-12-03 02:10:11.934685539 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mutt.h	2014-12-03 02:32:53.219123620 +0200
@@ -435,6 +435,8 @@
   OPTSAVEEMPTY,
   OPTSAVENAME,
   OPTSCORE,
+  OPTSIDEBAR,
+  OPTSIDEBARSORT,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
@@ -899,6 +901,7 @@
 {
   char *path;
   FILE *fp;
+  time_t atime;
   time_t mtime;
   off_t size;
   off_t vsize;
@@ -933,6 +936,7 @@
   unsigned int quiet : 1;	/* inhibit status messages? */
   unsigned int collapsed : 1;   /* are all threads collapsed? */
   unsigned int closing : 1;	/* mailbox is being closed */
+  unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
   /* driver hooks */
   void *data;			/* driver specific data */
diff -uNr mutt-1.5.23.nntp.xterm/muttlib.c mutt-1.5.23.nntp.xterm.sidebar/muttlib.c
--- mutt-1.5.23.nntp.xterm/muttlib.c	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/muttlib.c	2014-12-03 02:32:53.219123620 +0200
@@ -1288,6 +1288,8 @@
 	  pl = pw = 1;
 
 	/* see if there's room to add content, else ignore */
+        if ( DrawFullLine )
+        {
 	if ((col < COLS && wlen < destlen) || soft)
 	{
 	  int pad;
@@ -1331,6 +1333,52 @@
 	  col += wid;
 	  src += pl;
 	}
+        }
+        else
+        {
+	if ((col < COLS-SidebarWidth && wlen < destlen) || soft)
+        {
+	  int pad;
+
+	  /* get contents after padding */
+	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+	  len = mutt_strlen (buf);
+	  wid = mutt_strwidth (buf);
+
+	  /* try to consume as many columns as we can, if we don't have
+	   * memory for that, use as much memory as possible */
+	  pad = (COLS - SidebarWidth - col - wid) / pw;
+	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+	    pad = ((signed)(destlen - wlen - len)) / pl;
+	  if (pad > 0)
+	  {
+	    while (pad--)
+	    {
+	      memcpy (wptr, src, pl);
+	      wptr += pl;
+	      wlen += pl;
+	      col += pw;
+	    }
+	  }
+	  else if (soft && pad < 0)
+	  {
+	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+	    *wptr = 0;
+	    /* make sure right part is at most as wide as display */
+	    len = mutt_wstr_trunc (buf, destlen, COLS, &wid);
+	    /* truncate left so that right part fits completely in */
+	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad, &col);
+	    wptr = dest + wlen;
+	  }
+	  if (len + wlen > destlen)
+	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - SidebarWidth - col, NULL);
+	  memcpy (wptr, buf, len);
+	  wptr += len;
+	  wlen += len;
+	  col += wid;
+	  src += pl;
+	}
+        }
 	break; /* skip rest of input */
       }
       else if (ch == '|')
diff -uNr mutt-1.5.23.nntp.xterm/mx.c mutt-1.5.23.nntp.xterm.sidebar/mx.c
--- mutt-1.5.23.nntp.xterm/mx.c	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mx.c	2014-12-03 02:32:53.220123630 +0200
@@ -601,6 +601,7 @@
  *		M_APPEND	open mailbox for appending
  *		M_READONLY	open mailbox in read-only mode
  *		M_QUIET		only print error messages
+ *		M_PEEK		revert atime where applicable
  *	ctx	if non-null, context struct to use
  */
 CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
@@ -623,6 +624,8 @@
     ctx->quiet = 1;
   if (flags & M_READONLY)
     ctx->readonly = 1;
+  if (flags & M_PEEK)
+    ctx->peekonly = 1;
 
   if (flags & (M_APPEND|M_NEWFOLDER))
   {
@@ -728,9 +731,21 @@
 void mx_fastclose_mailbox (CONTEXT *ctx)
 {
   int i;
+#ifndef BUFFY_SIZE
+  struct utimbuf ut;
+#endif
 
   if(!ctx) 
     return;
+#ifndef BUFFY_SIZE
+  /* fix up the times so buffy won't get confused */
+  if (ctx->peekonly && ctx->path && ctx->mtime > ctx->atime)
+  {
+    ut.actime = ctx->atime;
+    ut.modtime = ctx->mtime;
+    utime (ctx->path, &ut); 
+  }
+#endif
 
   /* never announce that a mailbox we've just left has new mail. #3290
    * XXX: really belongs in mx_close_mailbox, but this is a nice hook point */
diff -uNr mutt-1.5.23.nntp.xterm/mx.h mutt-1.5.23.nntp.xterm.sidebar/mx.h
--- mutt-1.5.23.nntp.xterm/mx.h	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/mx.h	2014-12-03 02:32:53.220123630 +0200
@@ -60,6 +60,7 @@
 int mh_read_dir (CONTEXT *, const char *);
 int mh_sync_mailbox (CONTEXT *, int *);
 int mh_check_mailbox (CONTEXT *, int *);
+void mh_buffy_update (const char *, int *, int *, int *);
 int mh_check_empty (const char *);
 
 int maildir_read_dir (CONTEXT *);
diff -uNr mutt-1.5.23.nntp.xterm/OPS mutt-1.5.23.nntp.xterm.sidebar/OPS
--- mutt-1.5.23.nntp.xterm/OPS	2014-12-03 02:09:36.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/OPS	2014-12-03 02:32:53.217123600 +0200
@@ -198,3 +198,8 @@
 OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
 OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
 OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
+OP_SIDEBAR_SCROLL_UP "scroll the mailbox pane up 1 page"
+OP_SIDEBAR_SCROLL_DOWN "scroll the mailbox pane down 1 page"
+OP_SIDEBAR_NEXT "go down to next mailbox"
+OP_SIDEBAR_PREV "go to previous mailbox"
+OP_SIDEBAR_OPEN "open hilighted mailbox"
diff -uNr mutt-1.5.23.nntp.xterm/pager.c mutt-1.5.23.nntp.xterm.sidebar/pager.c
--- mutt-1.5.23.nntp.xterm/pager.c	2014-12-03 02:10:11.934685539 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/pager.c	2014-12-03 02:32:53.220123630 +0200
@@ -29,6 +29,7 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #include "mutt_crypt.h"
 
@@ -1100,6 +1101,7 @@
   wchar_t wc;
   mbstate_t mbstate;
   int wrap_cols = mutt_term_width ((flags & M_PAGER_NOWRAP) ? 0 : Wrap);
+  wrap_cols -= SidebarWidth;
 
   if (check_attachment_marker ((char *)buf) == 0)
     wrap_cols = COLS;
@@ -1769,7 +1771,7 @@
     if ((redraw & REDRAW_BODY) || topline != oldtopline)
     {
       do {
-	move (bodyoffset, 0);
+	move (bodyoffset, SidebarWidth);
 	curline = oldtopline = topline;
 	lines = 0;
 	force_redraw = 0;
@@ -1782,6 +1784,7 @@
 			    &QuoteList, &q_level, &force_redraw, &SearchRE) > 0)
 	    lines++;
 	  curline++;
+  	  move(lines + bodyoffset, SidebarWidth);
 	}
 	last_offset = lineInfo[curline].offset;
       } while (force_redraw);
@@ -1794,6 +1797,7 @@
 	  addch ('~');
 	addch ('\n');
 	lines++;
+  	move(lines + bodyoffset, SidebarWidth);
       }
       NORMAL_COLOR;
 
@@ -1817,22 +1821,22 @@
 	strfcpy(pager_progress_str, (topline == 0) ? "all" : "end", sizeof(pager_progress_str));
 
       /* print out the pager status bar */
-      move (statusoffset, 0);
+      move (statusoffset, SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
 
       if (IsHeader (extra) || IsMsgAttach (extra))
       {
-	size_t l1 = COLS * MB_LEN_MAX;
+	size_t l1 = (COLS-SidebarWidth) * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
-	mutt_paddstr (COLS, buffer);
+	mutt_paddstr (COLS-SidebarWidth, buffer);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (COLS, bn);
+	mutt_paddstr (COLS-SidebarWidth, bn);
       }
       NORMAL_COLOR;
       if (option(OPTXTERMSETTITLES))
@@ -1849,16 +1853,21 @@
       /* redraw the pager_index indicator, because the
        * flags for this message might have changed. */
       menu_redraw_current (index);
+      draw_sidebar(MENU_PAGER);
 
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
  
-      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), 0);
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
-      mutt_paddstr (COLS, buffer);
+      mutt_paddstr (COLS-SidebarWidth, buffer);
       NORMAL_COLOR;
     }
 
+    /* if we're not using the index, update every time */
+    if ( index == 0 )
+      draw_sidebar(MENU_PAGER);
+
     redraw = 0;
 
     if (option(OPTBRAILLEFRIENDLY)) {
@@ -2847,6 +2856,13 @@
 	mutt_what_key ();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+	scroll_sidebar(ch, MENU_PAGER);
+ 	break;
+
       default:
 	ch = -1;
 	break;
diff -uNr mutt-1.5.23.nntp.xterm/sidebar.c mutt-1.5.23.nntp.xterm.sidebar/sidebar.c
--- mutt-1.5.23.nntp.xterm/sidebar.c	1970-01-01 02:00:00.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/sidebar.c	2014-12-03 02:32:53.220123630 +0200
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */ 
+
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_menu.h"
+#include "mutt_curses.h"
+#include "sidebar.h"
+#include "buffy.h"
+#include <libgen.h>
+#include "keymap.h"
+#include <stdbool.h>
+
+/*BUFFY *CurBuffy = 0;*/
+static BUFFY *TopBuffy = 0;
+static BUFFY *BottomBuffy = 0;
+static int known_lines = 0;
+
+static int quick_log10(int n)
+{
+        char string[32];
+        sprintf(string, "%d", n);
+        return strlen(string);
+}
+
+void calc_boundaries (int menu)
+{
+	BUFFY *tmp = Incoming;
+
+	if ( known_lines != LINES ) {
+		TopBuffy = BottomBuffy = 0;
+		known_lines = LINES;
+	}
+	for ( ; tmp->next != 0; tmp = tmp->next )
+		tmp->next->prev = tmp;
+
+	if ( TopBuffy == 0 && BottomBuffy == 0 )
+		TopBuffy = Incoming;
+	if ( BottomBuffy == 0 ) {
+		int count = LINES - 2 - (menu != MENU_PAGER || option(OPTSTATUSONTOP));
+		BottomBuffy = TopBuffy;
+		while ( --count && BottomBuffy->next )
+			BottomBuffy = BottomBuffy->next;
+	}
+	else if ( TopBuffy == CurBuffy->next ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		BottomBuffy = CurBuffy;
+		tmp = BottomBuffy;
+		while ( --count && tmp->prev)
+			tmp = tmp->prev;
+		TopBuffy = tmp;
+	}
+	else if ( BottomBuffy == CurBuffy->prev ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		TopBuffy = CurBuffy;
+		tmp = TopBuffy;
+		while ( --count && tmp->next )
+			tmp = tmp->next;
+		BottomBuffy = tmp;
+	}
+}
+
+char *make_sidebar_entry(char *box, int size, int new, int flagged)
+{
+	static char *entry = 0;
+	char *c;
+	int i = 0;
+	int delim_len = strlen(SidebarDelim);
+
+	c = realloc(entry, SidebarWidth - delim_len + 2);
+	if ( c ) entry = c;
+	entry[SidebarWidth - delim_len + 1] = 0;
+	for (; i < SidebarWidth - delim_len + 1; entry[i++] = ' ' );
+	i = strlen(box);
+	strncpy( entry, box, i < (SidebarWidth - delim_len + 1) ? i : (SidebarWidth - delim_len + 1) );
+
+        if (size == -1)
+                sprintf(entry + SidebarWidth - delim_len - 3, "?");
+        else if ( new ) {
+          if (flagged > 0) {
+              sprintf(
+		        entry + SidebarWidth - delim_len - 5 - quick_log10(size) - quick_log10(new) - quick_log10(flagged),
+		        "% d(%d)[%d]", size, new, flagged);
+          } else {
+              sprintf(
+                      entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(new),
+                      "% d(%d)", size, new);
+          }
+        } else if (flagged > 0) {
+              sprintf( entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(flagged), "% d[%d]", size, flagged);
+        } else {
+              sprintf( entry + SidebarWidth - delim_len - 1 - quick_log10(size), "% d", size);
+        }
+	return entry;
+}
+
+void set_curbuffy(char buf[LONG_STRING])
+{
+  BUFFY* tmp = CurBuffy = Incoming;
+
+  if (!Incoming)
+    return;
+
+  while(1) {
+    if(!strcmp(tmp->path, buf)) {
+      CurBuffy = tmp;
+      break;
+    }
+
+    if(tmp->next)
+      tmp = tmp->next;
+    else
+      break;
+  }
+}
+
+int draw_sidebar(int menu) {
+
+	int lines = option(OPTHELP) ? 1 : 0;
+	BUFFY *tmp;
+#ifndef USE_SLANG_CURSES
+        attr_t attrs;
+#endif
+        short delim_len = strlen(SidebarDelim);
+        short color_pair;
+
+        static bool initialized = false;
+        static int prev_show_value;
+        static short saveSidebarWidth;
+
+        /* initialize first time */
+        if(!initialized) {
+                prev_show_value = option(OPTSIDEBAR);
+                saveSidebarWidth = SidebarWidth;
+                if(!option(OPTSIDEBAR)) SidebarWidth = 0;
+                initialized = true;
+        }
+
+        /* save or restore the value SidebarWidth */
+        if(prev_show_value != option(OPTSIDEBAR)) {
+                if(prev_show_value && !option(OPTSIDEBAR)) {
+                        saveSidebarWidth = SidebarWidth;
+                        SidebarWidth = 0;
+                } else if(!prev_show_value && option(OPTSIDEBAR)) {
+                        SidebarWidth = saveSidebarWidth;
+                }
+                prev_show_value = option(OPTSIDEBAR);
+        }
+
+
+//	if ( SidebarWidth == 0 ) return 0;
+       if (SidebarWidth > 0 && option (OPTSIDEBAR)
+           && delim_len >= SidebarWidth) {
+         unset_option (OPTSIDEBAR);
+         /* saveSidebarWidth = SidebarWidth; */
+         if (saveSidebarWidth > delim_len) {
+           SidebarWidth = saveSidebarWidth;
+           mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar."));
+           sleep (2);
+         } else {
+           SidebarWidth = 0;
+           mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar. Please set your sidebar_width to a sane value."));
+           sleep (4); /* the advise to set a sane value should be seen long enough */
+         }
+         saveSidebarWidth = 0;
+         return (0);
+       }
+
+    if ( SidebarWidth == 0 || !option(OPTSIDEBAR)) {
+      if (SidebarWidth > 0) {
+        saveSidebarWidth = SidebarWidth;
+        SidebarWidth = 0;
+      }
+      unset_option(OPTSIDEBAR);
+      return 0;
+    }
+
+        /* get attributes for divider */
+	SETCOLOR(MT_COLOR_STATUS);
+#ifndef USE_SLANG_CURSES
+        attr_get(&attrs, &color_pair, 0);
+#else
+        color_pair = attr_get();
+#endif
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	/* draw the divider */
+
+	for ( ; lines < LINES-1-(menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+		move(lines, SidebarWidth - delim_len);
+		addstr(NONULL(SidebarDelim));
+#ifndef USE_SLANG_CURSES
+                mvchgat(lines, SidebarWidth - delim_len, delim_len, 0, color_pair, NULL);
+#endif
+	}
+
+	if ( Incoming == 0 ) return 0;
+	lines = option(OPTHELP) ? 1 : 0; /* go back to the top */
+
+	if ( known_lines != LINES || TopBuffy == 0 || BottomBuffy == 0 ) 
+		calc_boundaries(menu);
+	if ( CurBuffy == 0 ) CurBuffy = Incoming;
+
+	tmp = TopBuffy;
+
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	for ( ; tmp && lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); tmp = tmp->next ) {
+		if ( tmp == CurBuffy )
+			SETCOLOR(MT_COLOR_INDICATOR);
+		else if ( tmp->msg_unread > 0 )
+			SETCOLOR(MT_COLOR_NEW);
+		else if ( tmp->msg_flagged > 0 )
+		        SETCOLOR(MT_COLOR_FLAGGED);
+		else
+			SETCOLOR(MT_COLOR_NORMAL);
+
+		move( lines, 0 );
+		if ( Context && !strcmp( tmp->path, Context->path ) ) {
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+			tmp->msg_flagged = Context->flagged;
+		}
+		// check whether Maildir is a prefix of the current folder's path
+		short maildir_is_prefix = 0;
+		if ( (strlen(tmp->path) > strlen(Maildir)) &&
+			(strncmp(Maildir, tmp->path, strlen(Maildir)) == 0) )
+        		maildir_is_prefix = 1;
+		// calculate depth of current folder and generate its display name with indented spaces
+		int sidebar_folder_depth = 0;
+		char *sidebar_folder_name;
+		sidebar_folder_name = basename(tmp->path);
+		if ( maildir_is_prefix ) {
+			char *tmp_folder_name;
+			int i;
+			tmp_folder_name = tmp->path + strlen(Maildir);
+			for (i = 0; i < strlen(tmp->path) - strlen(Maildir); i++) {
+				if (tmp_folder_name[i] == '/') sidebar_folder_depth++;
+			}   
+			if (sidebar_folder_depth > 0) {
+				sidebar_folder_name = malloc(strlen(basename(tmp->path)) + sidebar_folder_depth + 1);
+				for (i=0; i < sidebar_folder_depth; i++)
+					sidebar_folder_name[i]=' ';
+				sidebar_folder_name[i]=0;
+				strncat(sidebar_folder_name, basename(tmp->path), strlen(basename(tmp->path)) + sidebar_folder_depth);
+			}
+		}
+		printw( "%.*s", SidebarWidth - delim_len + 1,
+			make_sidebar_entry(sidebar_folder_name, tmp->msgcount,
+			tmp->msg_unread, tmp->msg_flagged));
+		if (sidebar_folder_depth > 0)
+		        free(sidebar_folder_name);
+		lines++;
+	}
+	SETCOLOR(MT_COLOR_NORMAL);
+	for ( ; lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+		int i = 0;
+		move( lines, 0 );
+		for ( ; i < SidebarWidth - delim_len; i++ )
+			addch(' ');
+	}
+	return 0;
+}
+
+
+void set_buffystats(CONTEXT* Context)
+{
+        BUFFY *tmp = Incoming;
+        while(tmp) {
+                if(Context && !strcmp(tmp->path, Context->path)) {
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+                        break;
+                }
+                tmp = tmp->next;
+        }
+}
+
+void scroll_sidebar(int op, int menu)
+{
+        if(!SidebarWidth) return;
+        if(!CurBuffy) return;
+
+	switch (op) {
+		case OP_SIDEBAR_NEXT:
+			if ( CurBuffy->next == NULL ) return;
+			CurBuffy = CurBuffy->next;
+			break;
+		case OP_SIDEBAR_PREV:
+			if ( CurBuffy->prev == NULL ) return;
+			CurBuffy = CurBuffy->prev;
+			break;
+		case OP_SIDEBAR_SCROLL_UP:
+			CurBuffy = TopBuffy;
+			if ( CurBuffy != Incoming ) {
+				calc_boundaries(menu);
+				CurBuffy = CurBuffy->prev;
+			}
+			break;
+		case OP_SIDEBAR_SCROLL_DOWN:
+			CurBuffy = BottomBuffy;
+			if ( CurBuffy->next ) {
+				calc_boundaries(menu);
+				CurBuffy = CurBuffy->next;
+			}
+			break;
+		default:
+			return;
+	}
+	calc_boundaries(menu);
+	draw_sidebar(menu);
+}
+
diff -uNr mutt-1.5.23.nntp.xterm/sidebar.h mutt-1.5.23.nntp.xterm.sidebar/sidebar.h
--- mutt-1.5.23.nntp.xterm/sidebar.h	1970-01-01 02:00:00.000000000 +0200
+++ mutt-1.5.23.nntp.xterm.sidebar/sidebar.h	2014-12-03 02:32:53.220123630 +0200
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */ 
+
+#ifndef SIDEBAR_H
+#define SIDEBAR_H
+
+struct MBOX_LIST {
+	char *path;
+	int msgcount;
+	int new;
+} MBLIST;
+
+/* parameter is whether or not to go to the status line */
+/* used for omitting the last | that covers up the status bar in the index */
+int draw_sidebar(int);
+void scroll_sidebar(int, int);
+void set_curbuffy(char*);
+void set_buffystats(CONTEXT*);
+
+#endif /* SIDEBAR_H */
